<%
  # Custom component functions
  @state_colours = {
    'pending' => 'warning',
    'passed' => 'success',
    'failed' => 'danger',
    'pending (parent)' => 'secondary',
    'passed (parent)' => 'secondary',
    'failed (parent)' => 'secondary'
  }


  # Checks if a given pipeline is present in the purpose pipeline map for a specific purpose.
  #
  # @param pipeline_name [String] The name of the pipeline to check.
  # @param purpose_name [String] The name of the purpose to look for.
  #
  # @return [Boolean] Returns true if the pipeline is found in the keys of the purpose's pipeline map, false otherwise.
  def purpose_is_in_pipeline(pipeline_name, purpose_name)
    @purpose_pipeline_map[purpose_name].keys.include?(pipeline_name)
  end

  # Checks if the first purpose in a pipeline has occurred.
  #
  # @param pipeline_name [String] The name of the pipeline to check.
  # @param purpose_name [String] The name of the purpose to look for.
  #
  # @return [Boolean] Returns true if the purpose is the first in the pipeline and has occurred, false otherwise.
  def pipeline_first_purpose_has_occurred(pipeline_name, purpose_name)
    first_purpose_in_pipeline = @ordered_purposes_for_pipelines[pipeline_name].first

    # get list of purposes prior to the given purpose
    purposes_prior_to_purpose = @ordered_purpose_list[0..@ordered_purpose_list.index(purpose_name)]

    # has the first purpose in the pipeline occurred?
    purposes_prior_to_purpose.include?(first_purpose_in_pipeline)
  end

  # Checks if the last purpose in a pipeline is still to occur.
  #
  # @param pipeline_name [String] The name of the pipeline to check.
  # @param purpose_name [String] The name of the purpose to look for.
  #
  # @return [Boolean] Returns true if the purpose is the last in the pipeline and has not occurred, false otherwise.
  def pipeline_last_purpose_is_still_to_occur(pipeline_name, purpose_name)
    last_purpose_in_pipeline = @ordered_purposes_for_pipelines[pipeline_name].last

    # get list of purposes after the given purpose
    purposes_after_purpose = @ordered_purpose_list[@ordered_purpose_list.index(purpose_name)..-1]

    # has the last purpose in the pipeline occurred?
    purposes_after_purpose.include?(last_purpose_in_pipeline)
  end

  def show_pipeline_in_graph(pipeline_name, purpose_name)
    purpose_is_in_pipeline(pipeline_name, purpose_name) ||
      pipeline_first_purpose_has_occurred(pipeline_name, purpose_name) &&
      pipeline_last_purpose_is_still_to_occur(pipeline_name, purpose_name)
  end

  def is_first_purpose_in_pipeline(pipeline_name, purpose_name)
    @ordered_purposes_for_pipelines[pipeline_name].first == purpose_name
  end

  def is_last_purpose_in_pipeline(pipeline_name, purpose_name)
    @ordered_purposes_for_pipelines[pipeline_name].last == purpose_name
  end

  def graph_classes(pipeline_name, purpose_name)
    # purpose_pipeline_map is a hash of hashes, like:
    #   "Purpose 2" => {
    #     "Pipeline A" => {
    #       "parent" => "Purpose 1",
    #       "child" => "Purpose 3"
    #     },
    #     "Pipeline B" => {
    #       "parents" => "Purpose 1",
    #       "child" => nil
    #     }
    parent_purpose_name = @purpose_pipeline_map.dig(pipeline_name, purpose_name, 'parent')
    child_purpose_name = @purpose_pipeline_map.dig(pipeline_name, purpose_name, 'child')

    # provide spacing
    classes = ['pipeline']
    # show the coloured line
    classes << 'pipeline-shown' if show_pipeline_in_graph(pipeline_name, purpose_name)
    # indicate that the purpose is part of the pipeline
    classes << 'pipeline-purpose' if purpose_is_in_pipeline(pipeline_name, purpose_name)
    # decoration for the first and last purposes in each pipeline
    classes << 'pipeline-start' if is_first_purpose_in_pipeline(pipeline_name, purpose_name)
    classes << 'pipeline-end' if is_last_purpose_in_pipeline(pipeline_name, purpose_name)

    classes.join(' ')
  end

  def state_text_badge(state, text)
    content_tag(:span, text, class: "badge badge-pill badge-#{@state_colours[state]}")
  end

  def state_with_children_badge(labware_data)
    state_with_children = labware_data[:state_with_children]
    state_text_badge(state_with_children, state_with_children.humanize)
  end

  def render_header
    content_tag(:tr) do
      content_tag(:th, 'Barcode') +
      content_tag(:th, 'Created') +
      content_tag(:th, 'State') +
      content_tag(:th, 'Updated')
    end
  end

  def render_row(labware_data)
    content_tag(:tr) do
      content_tag(:td, link_to("#{labware_data[:record].labware_barcode&.human}", url_for(labware_data[:record]))) +
      content_tag(:td, labware_data[:record].created_at&.strftime('%Y-%m-%d')) +
      content_tag(:td, state_with_children_badge(labware_data) ) +
      content_tag(:td, labware_data[:record].updated_at.strftime('%Y-%m-%d'))
    end
  end

  def render_table(show_labware_with_children)
    if @purpose.nil?
      grouped_data = []
    else
      grouped_data =
        @grouped[@purpose].select do |labware_data|
         labware_data[:record].has_children == show_labware_with_children
         end
    end

    number_colums = render_header.scan(/<th>/).size

    content_tag(:table, class: 'table table-striped table-sm border', style: 'table-layout: fixed') do
      content_tag(:thead) { render_header } +
        content_tag(:tbody) do
          if grouped_data.empty?
            content_tag(:tr) { content_tag(:td, 'No labware found', colspan: number_colums, class: 'text-center text-muted') }
          else
            # list of labware, with a link to each
            grouped_data.map { |labware_data| render_row(labware_data) }.join.html_safe
          end
        end
    end
  end
%>

<%= content do %>
  <h1>Limber Pipeline Progress Overview <small class="text-muted"><br/>
  <%= @pipeline_group_name -%></small></h1>

  <!-- filters - reload the page with a new param -->

  <!-- Date selectors -->
  <div class="btn-group btn-group-sm mb-2" role="group" aria-label="Date selectors">
    <%
      @dates = {
        'All time' => Date.new(1970, 1, 1),
        'Last month' => Date.today.prev_month,
        'Last week' => Date.today.prev_week,
        'Yesterday' => Date.yesterday,
        'Today' => Date.today
      }
    %>
    <%=
      @dates.map do |label, date|
        link_to label, pipeline_progress_overview_path(id: @pipeline_group_name, date: date), method: :get, class: "btn btn-secondary #{'active' if date == @from_date}"
      end.join.html_safe
    %>
  </div>

  <!-- two columns, left for the purposes, right for the labware list -->
  <div class="row">
    <div class="col-lg-3 col-md-4">
      <h3 class="text-center">Purposes</h3>

    <!-- purpose cards, showing counts of labware for each state -->
    <% @ordered_purpose_list.each do |purpose_name| %>
      <div class="stacker">
        <%= content_tag :div, class: "stacker-graph" do %>
          <% @pipelines_for_group.each do |pipeline_name| %>
            <%= content_tag :span, 'â–¼', class: graph_classes(pipeline_name, purpose_name) %>
          <% end %>
        <% end %>
        <%= card title: "#{purpose_name} (#{@grouped[purpose_name].size})", css_class: 'lightweight-card rounded-0 text-center' do %>

          <% @grouped_state_counts[purpose_name].each do |state_with_children, count| %>
            <%= state_text_badge(state_with_children, "#{state_with_children.humanize} #{count}") %>
          <% end %>

          <span class="float-right">
            <%= link_to ">", pipeline_progress_overview_path(id: @pipeline_group_name, purpose: purpose_name, date: @from_date), class: "btn btn-sm btn-info" %>
          </span>
        <% end %>
      </div>

    <% end %>
    </div>

    <!-- labware lists -->
    <div class="col-lg-9 col-md-8">
      <h3><%= @purpose || 'Labware' %></h3>
      <%= render_table(false) %> <!-- show_labware_with_children = false -->

      <h5><%= @purpose || 'Labware' %> with Children</h5>
      <%= render_table(true) %> <!-- show_labware_with_children = true -->
    </div>
  </div>

<% end %>
