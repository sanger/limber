# Pipelines yaml files

There are a number of `*.yml` files located in `app/config/pipelines/` these
configure the flow of plate purposes through a {Pipeline}. Limber automatically
loads all `.yml` files within this directory into {PipelineList}.
Filenames, and the grouping of pipelines within files, have no functional
relevance, and are intended for organizational reasons.

Loading of yaml files is handled by {ConfigLoader::PipelinesLoader} which
loads all files, detects potential duplicates, and populates the {PipelineList}.

> **TIP**
> It is suggested that you create a new file for each new 'pipeline'. In most
> cases this file will actually contain a handful of internal 'pipelines'
> reflecting branches, or different stages of the process.

> **TIP**
> In most Limber pipelines, the final multiplex library tube is created
> upfront by the limber_multiplexing request. This allows the SSRs to access
> the sequencing requests easily prior to the completion of library creation,
> allowing for the addition of removal of requests. A side effect of this is
> that any Limber pipelines using the standard limber_multiplexing request
> share the final tube purpose, 'LB Lib Pool Norm'. This is defined in:
> {file:config/purposes/final_tube.yml}

## An example file

This is an example yaml file configuring a WGS (whole genome sequencing)
pipeline.

```yaml
---
WGS: # Top of the pipeline (Library Prep)
  filters:
    request_type_key:
    - limber_wgs
    - limber_lcmb
    - limber_rnaa
    library_type: Standard
  library_pass: LB Lib PCR-XP
  relationships:
    LB Cherrypick: LB Shear
    LB Shear: LB Post Shear
    LB Post Shear: LB End Prep
    LB End Prep: LB Lib PCR
    LB Lib PCR: LB Lib PCR-XP
WGS MX: # Bottom of the pipeline (Pooling and normalization)
  filters:
    request_type_key:
    - limber_multiplexing
  relationships:
    LB Lib PCR-XP: LB Lib Pool
    LB Lib Pool: LB Lib Pool Norm
```

The rest of the document describes the structure of this file, and what each of the keys do.

## Top level

Each file is a `.yml` file located in `app/config/pipelines`, it contains the
configuration for one or more {Pipeline pipelines}.

The top level structure consists of series of keys, uniquely identifying each
pipeline. Keys need to be unique across *all* pipelines, not just those within
the same file. Limber will detect duplicate keys, and will raise an exception
on boot.

The key will be used to set the {Pipeline#name}, this is exposed in the
pipelines overview page, and may get shown to the user in future.

The values in turn are used to describe each {Pipeline}. The valid options are details in Pipeline below.

### Pipeline

Each pipeline configures a name, high-level behaviour and a list of
relationships. As discussed above, the key is a unique value, which gets used
to set the pipeline's name.

@see Pipeline for the Ruby objects generated by this configuration.

```yaml
WGS: # Top of the pipeline (Library Prep)
  filters:
    request_type_key:
    - limber_wgs
    - limber_lcmb
    - limber_rnaa
    library_type: Standard
  library_pass: LB Lib PCR-XP
  relationships:
    LB Cherrypick: LB Shear
    LB Shear: LB Post Shear
    LB Post Shear: LB End Prep
    LB End Prep: LB Lib PCR
    LB Lib PCR: LB Lib PCR-XP
```

The other keys are detailed below.

#### Filters

Filters are the way in which a pipeline works out if it is in progress. It
consists of a series of keys, and their acceptable values. Keys should be
attributes on {Sequencescape::Api::V2::Request request} (eg. library_type)
whereas values are either an array of acceptable values, or a single acceptable
value.

```yaml
filters:
  request_type_key:
  - limber_wgs
  - limber_lcmb
  - limber_rnaa
  library_type: Standard
```

Indicates that this pipeline can be used for requests with a request type of 'limber_wgs', 'limber_lcmb' or 'limber_rnaa', and a library type os 'Standard'.

The most common keys to filter on are request_type and library_type.

All filters must be fulfilled for a pipeline to be considered valid.

#### library_pass

library_pass indicates the plate purposes for which the Lims should suggest the
'Charge and Pass Libraries' option. The values should be strings matching purpose names specified in `config/purposes/*.yml`.

It can be a string if library pass should be suggested at a single step:

``` yaml
library_pass: LB Lib PCR-XP
```

Or an array, if there are multiple points at which a library can be passed:

``` yaml
  library_pass:
  - LB Cap Lib PCR-XP
  - LB Cap Lib Pool
```

> **TIP**
> library_pass usually occurs on the last plate of the pipeline, immediately
> prior to multiplexing and normalization. This is the point at which the
> pipeline transitions from the library creation request (eg. limber_wgs)
> to the multiplexing request (eg. limber_multiplexing). You'll see this
> reflected in the example above, with the 'WGS' and 'WGS MX' pipelines.
>
> This split ensures that customers can request re-pools of existing libraries,
> without incurring further charges for library creation.
>
> It is common, although not necessary, to specify both library_creation and
> multiplexing sections of a pipeline in the same file.
>
> library_pass is not specified for the final tube in the WGS MX pipeline
> because:
>
> - The behaviour is already handled by passing the tube itself
> - Multiplexing is not charged for, and rarely failed, so an explicit
>   step is unnecessary and confusing.
>

#### relationships

The relationships is a hash representing transitions from parent labware to
child labware. Both keys and values are strings matching purpose names specified
in `config/purposes/*.yml`.

```yaml
relationships:
  LB Cherrypick: LB Shear
  LB Shear: LB Post Shear
  LB Post Shear: LB End Prep
  LB End Prep: LB Lib PCR
  LB Lib PCR: LB Lib PCR-XP
```

The above shows a transition from 'LB Cherrypick' to 'LB Shear', 'LB Shear' to 'LB Post Shear' and so on.

It should be noted that because the above structure is a hash, it is not possible to reflect a branching pipeline. Instead, each branch of the pipeline
can be represented by a separate pipeline within th same file.

For example, the heron pipeline has A and B forks, representing the PCR 1 and
PCR 2 routes.

```yaml
---
Heron-384 A: # Heron 384-well pipeline specific to PCR 1 plate
  filters:
    request_type_key: limber_heron
    library_type: PCR amplicon ligated adapters 384
  library_pass: LHR-384 Lib PCR
  relationships:
    LHR-384 RT: LHR-384 PCR 1
    LHR-384 PCR 1: LHR-384 cDNA
    LHR-384 cDNA: LHR-384 XP
    LHR-384 XP: LHR-384 End Prep
    LHR-384 End Prep: LHR-384 AL Lib
    LHR-384 AL Lib: LHR-384 Lib PCR
Heron-384 B: # Heron 384-well pipeline specific to PCR 2 plate (uses above relationships after cDNA plate)
  filters:
    request_type_key: limber_heron
    library_type: PCR amplicon ligated adapters 384
  relationships:
    LHR-384 RT: LHR-384 PCR 2
    LHR-384 PCR 2: LHR-384 cDNA
```
